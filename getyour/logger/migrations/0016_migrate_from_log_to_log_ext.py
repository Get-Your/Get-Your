# Generated by Django 4.1.8 on 2024-01-10 23:52

from django.db import migrations

from log.models import Detail as OldDetail
from logger.models import Detail as NewDetail


def apply_migration(apps, schema_editor):
    # Transfer any data from OldDetail to NewDetail
    if OldDetail.objects.count() > 0:

        # auto_now_add must be False during this transfer to preserve timestamps
        if NewDetail.created_at.field.auto_now_add is True:
            raise Exception("The 'auto_now_add' option of logger.Detail.created_at must be set to False for this data transfer. No extra migrations are necessary; set created_at.auto_now_add=False, then run the same 'migrate' command again.")

        # To minimize the risk of data loss, take any existing records in NewDetail
        # and offset them by the maximum ID in OldDetail
        if NewDetail.objects.count() > 0:

            oldId_max = OldDetail.objects.order_by('-id').first().id
            newId_min = NewDetail.objects.order_by('id').first().id
            idOffset = oldId_max - newId_min + 1

            # Increase each ID in NewDetail by idOffset (starting with the max, to
            # avoid UNIQUE violations)
            newId_max = NewDetail.objects.order_by('-id').first().id
            for iterid in range(newId_max, 0, -1):
                NewDetail.objects.filter(id=iterid).update(id=iterid+idOffset)

        # Now that there are no constraint issues, copy from OldDetail directly to
        # NewDetail
        NewDetail.objects.bulk_create(
            OldDetail.objects.order_by('id')
        )

        print("\n\nData migration from 'log' to 'logger' complete. Set the 'auto_now_add' option of logger.Detail.created_at to True.\n\n")

    else:
        msg = "\n\nNo data in 'log' to transfer to 'logger'."
        if NewDetail.created_at.field.auto_now_add is False:
            msg += " Set the 'auto_now_add' option of logger.Detail to True."

        print(msg + "\n\n")


def revert_migration(apps, schema_editor):
    # Intentionally making this non-revertable. The next step is to delete the
    # 'log' model, so allowing reversion of this step in the future would likely
    # result in data loss.
    if NewDetail.objects.count() > 0:
        confirmRevert = input("\n\nData exist in logger.Detail; to prevent data loss, reverting the data transfer from 'log' will make no changes, but migrating again may add additional data from 'log'. Press 'y' to continue or anything else to abort: ")
        if confirmRevert.lower() != 'y':
            raise KeyboardInterrupt("User aborted the migration reversion.")


class Migration(migrations.Migration):
    dependencies = [
        ("logger", "0015_alter_detail_has_been_addressed"),
    ]

    operations = [
        migrations.RunPython(apply_migration, revert_migration),
    ]
